# FID-20251127-001: Real-Time Socket.io Chat & Notification System (Phase 1 MVP)

**Status:** PLANNED  
**Priority:** HIGH  
**Complexity:** 3/5  
**Created:** 2025-11-27  
**Estimated:** 6-8h (real: ~45-60m with ECHO)

## Summary
Implements foundational realtime layer via Socket.io: multi-room chat (global, company, politics, DM) + system notification broadcast (achievement, legislation, lobby payment, telemetry). Establishes persistence, rate limiting, profanity filtering, authenticated message flow, and extensible emitter utilities for future gameplay events. Delivers immediate manual test value (user preference) without waiting for extended test suite build-out.

## Business / Gameplay Value
- Increases player retention via synchronous interaction.
- Enables political coordination and lobbying negotiations in real time.
- Immediate surface for future guild/alliance system & event broadcasting.
- Provides basis for notification-driven engagement loops (achievements, legislative updates).

## Acceptance Criteria
- Users connect, join rooms, send/receive messages with <300ms local latency.
- Channels implemented: global, politics, company:{companyId}, dm:{uidA_uidB}.
- Server-side auth validation (reject unauthenticated sockets gracefully).
- Profanity filtered (blocked words replaced with `***`).
- Rate limit: ≤10 messages per 10s sliding window; >30 messages per 60s triggers temp disconnect (30s). Warning event before hard limit.
- Messages persisted with fields: _id, room, senderId, content, createdAt, edited=false, system=false.
- History API / socket event returns last 50 messages with cursor pagination.
- Typing indicators (debounced; cleared after 2s inactivity or on disconnect).
- System notification stubs emit correctly over `/system` namespace.
- Frontend ChatPanel shows real-time flow + optimistic pending state replaced by ACK.
- Shared Zod validation for incoming message payload.
- 0 new TypeScript errors; no `any` usage.
- DRY maintained (single profanity + validation utility reused across handlers).

## Approach (Phases)
1. Models & Types: Define ChatMessage schema + TypeScript interfaces; Zod validation.
2. Socket Initialization: Enhance `server.js` with Socket.io instance, auth middleware, namespaces.
3. Core Event Handlers: message:send, message:history, join/leave, typing:start/stop; implement ACK pipeline.
4. Rate Limiting & Moderation: In-memory sliding window map; abstract interface to allow Redis later.
5. Emitters: `emitAchievementUnlock`, `emitLegislationUpdate`, etc. (stubs with console instrumentation).
6. Frontend Components: ChatPanel + channel tabs + message list (virtualized) + input.
7. Manual QA: Multi-tab browser tests, spam simulation, disconnect/reconnect, DM consistency.
8. Documentation: Generate completion report after implementation (docs/REALTIME_CHAT_MVP_FID-20251127-001.md).

## File Plan
NEW:
- `src/lib/db/models/ChatMessage.ts`
- `src/lib/realtime/socketInit.ts`
- `src/lib/realtime/events/chatHandlers.ts`
- `src/lib/realtime/events/systemHandlers.ts`
- `src/lib/realtime/rateLimit.ts`
- `src/lib/realtime/emitters.ts`
- `src/lib/validations/chatMessage.ts`
- `src/components/realtime/ChatPanel.tsx`
- `src/components/realtime/ChatChannelTabs.tsx`
- `src/components/realtime/MessageList.tsx`
- `src/components/realtime/MessageInput.tsx`
MOD:
- `server.js` (initialize sockets)
- (Later) Achievement / Legislation utilities (add emitter calls)

## Data Model (Initial)
```ts
interface ChatMessage {
  _id: ObjectId;
  room: string; // 'global' | `company:${id}` | 'politics' | `dm:${uidA}_${uidB}`
  senderId: ObjectId;
  content: string; // <= 500 chars
  createdAt: Date;
  edited: boolean;
  system: boolean;
}
```

## Dependencies
- NextAuth session for auth context.
- MongoDB connection utilities.
- Existing `profanityFilter.ts` for moderation.
- Future scaling: Redis adapter (not required MVP).

## Risks & Mitigations
| Risk | Mitigation |
|------|------------|
| Spam/Flood | Sliding window + disconnect threshold |
| Memory leak (typing timers) | Central timer registry + cleanup on disconnect |
| DM room collisions | Canonical pair ordering (lexical) |
| Future horizontal scaling | Abstract rateLimit storage, interface-based |

## Metrics / Instrumentation
- Log `[RT] connect`, `[RT] join room`, `[RT] msg persisted (ms latency)`.
- Capture message throughput counts per minute (for tuning).
- Track rate-limit hits and disconnect events.

## Manual Test Plan (User Preference)
- Open two browsers: send messages across all rooms, verify isolation.
- Rapid-send 15 messages in <10s → confirm warning then enforcement.
- Toggle between company room and global; verify scroll position retention.
- Initiate DM and verify room naming consistent (`uidSmall_uidLarge`).
- Trigger stub notification (`emitAchievementUnlock`) and confirm display in system channel.

## Future Expansion (Post-MVP)
- Presence & online roster.
- Reactions / editing / deletion.
- Threading & rich embeds.
- Push notifications & mobile adaptation.
- Moderation dashboard (mute, ban, audit log).

## Strategic Alignment
Builds social substrate enabling politics coordination, alliance formation, and long-term retention loops central to MMO vision.

## Notes
Utility-first: validations + rate limiting + emitters before UI. No placeholder code. All handlers documented with JSDoc. Socket lifecycle errors captured and logged with structured context.

